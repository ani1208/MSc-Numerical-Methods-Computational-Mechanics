# -*- coding: utf-8 -*-
"""damage_vfinal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eBP-t_K7L1drx80DqYtxyqD9zMrix7gd
"""

import numpy as np
import matplotlib.pyplot as plt

# ------------------------------ Input & Mesh ------------------------------ #
def GetInput():
    L = 1
    nelem = 50
    x = np.linspace(0, L, nelem + 1)
    geom_Le = np.full(nelem, L / nelem)
    coordinates = np.concatenate(([0], np.cumsum(geom_Le)))
    nodes = np.arange(0, nelem + 1)
    dofs = nodes.copy()
    element = np.column_stack((np.arange(0, nelem), np.arange(1, nelem + 1)))
    dofs_element = element.copy()
    fixed_nodes = [0, len(nodes) - 1]
    T = 1
    delt = 0.001

    E = 70000e6
    sigma_u = 200e6
    r0 = sigma_u / np.sqrt(E)
    Ahs = 0.5
    Bhs = 0
    q_inf = Bhs * r0

    input_data = {
        'L': L, 'nelem': nelem, 'x': x, 'geom_Le': geom_Le, 'nodes': nodes,
        'dofs': dofs, 'coordinates': coordinates, 'element': element,
        'dofs_element': dofs_element, 'E': E, 'T': T, 'delt': delt,
        'fixed_nodes': fixed_nodes, 'sigma_u': sigma_u, 'r0': r0,
        'Ahs': Ahs, 'Bhs': Bhs, 'q_inf': q_inf
    }
    return input_data

# ------------------------- Damage + Tangent Update ------------------------- #
def update_damage_consistent(u, q_old, r_old, d_old, E, input_data):
    nelem = input_data['nelem']
    f_int_global = np.zeros(len(input_data['nodes']))
    eps_current = np.zeros(nelem)
    sigma_current = np.zeros(nelem)
    Etang = np.full(nelem, E)

    q_inf = input_data['q_inf']
    r0 = input_data['r0']
    Ahs = input_data['Ahs']
    L = input_data['L']

    q = q_old.copy()
    r = r_old.copy()
    d = d_old.copy()

    for idx, (i, j) in enumerate(input_data['element']):
        n1c, n2c = get_element_node_coords(idx, input_data)
        h = n2c - n1c
        B = np.array([[-1/h, 1/h]])
        eps_elem = np.dot(B, [u[i], u[j]])[0]
        eps_current[idx] = eps_elem

        sig_eff = E * eps_elem
        tau_eps = np.abs(eps_elem) * np.sqrt(E)

        if tau_eps > r_old[idx]:
            r[idx] = tau_eps
            q[idx] = q_inf - (q_inf - r0) * np.exp(-Ahs * (r[idx] - r0) / r0)
            d[idx] = 1.0 - q[idx] / r[idx]
            H = (Ahs * (q_inf - r0) / r0) * np.exp(-Ahs * (r[idx] - r0) / r0)
            Etang[idx] = (1 - d[idx]) * E - (sig_eff ** 2 / r[idx]**3) * (q[idx] - H * r[idx])
        else:
            Etang[idx] = (1 - d[idx]) * E

        sigma = (1 - d[idx]) * sig_eff
        sigma_current[idx] = sigma

        A = get_A_value((n1c + n2c) / 2, L)
        f_int = A * h * np.dot(B.T, sigma)
        f_int_global[i] += f_int[0]
        f_int_global[j] += f_int[1]

    return d, r, q, Etang, f_int_global, eps_current, sigma_current

# ------------------------------ Helper Functions ------------------------------ #
def disp_func(t, T, m=2, um=0.005):
    return um * np.sin((m * np.pi * t) / T)

def get_element_node_coords(element_id, input_data):
    node1_id = input_data['element'][element_id, 0]
    node2_id = input_data['element'][element_id, 1]
    return input_data['coordinates'][node1_id], input_data['coordinates'][node2_id]

def get_A_value(x_val, L):
    if x_val < 0.4 * L:
        return 0.01
    elif 0.4 * L <= x_val <= 0.6 * L:
        return 0.001
    else:
        return 0.01

def K_Assem(input_data, u, d, Etang):
    n_nodes = len(input_data['nodes'])
    K_global = np.zeros((n_nodes, n_nodes))

    for elem in range(input_data['nelem']):
        n1c, n2c = get_element_node_coords(elem, input_data)
        midpt = (n1c + n2c) / 2
        h = n2c - n1c
        A = get_A_value(midpt, input_data['L'])
        B = np.array([[-1/h, 1/h]])
        element_dofs = input_data['dofs_element'][elem]
        K_elem = A * Etang[elem] * np.dot(B.T, B) * h
        for i, dof_i in enumerate(element_dofs):
            for j, dof_j in enumerate(element_dofs):
                K_global[dof_i, dof_j] += K_elem[i, j]

    return K_global

# ------------------------------ Main Solver ------------------------------ #
input_data = GetInput()
num_nodes = len(input_data['nodes'])
fixed_nodes = input_data['fixed_nodes']
free_nodes = list(set(range(num_nodes)) - set(fixed_nodes))

u = np.zeros(num_nodes)
f_ext = np.zeros(num_nodes)
d = np.zeros(input_data['nelem'])
r = np.full(input_data['nelem'], input_data['r0'])
q = np.full(input_data['nelem'], input_data['q_inf'])
E = input_data['E']

eps_history = []
sigma_history = []
damage_history = []
u_history = [u.copy()]
residual_history = []
time_steps = np.arange(0, input_data['T'] + input_data['delt'], input_data['delt'])

max_iter = 10
tol = 1e-8

for t in time_steps:
    print('--------------------------------------------------------------------------------------------------------------')
    print(f'\nTime: {t:.2f}')
    u[-1] = disp_func(t, input_data['T'])
    residuals = []

    for iteration in range(max_iter):
        d_trial, r_trial, q_trial, Etang, f_int, eps, sigma = update_damage_consistent(u, q, r, d, E, input_data)

        K = K_Assem(input_data, u, d_trial, Etang)
        R = -f_int[free_nodes]
        residual = np.linalg.norm(R)
        residuals.append(residual)
        print(f'Iteration {iteration + 1}, Residual: {residual:.2e}')

        if residual < tol:
            print(f'Converged at t = {t:.2f} after {iteration + 1} iterations')
            d = d_trial.copy()
            q = q_trial.copy()
            r = r_trial.copy()
            break

        du = np.linalg.solve(K[np.ix_(free_nodes, free_nodes)], R)
        u[free_nodes] += du

    eps_history.append(eps.copy())
    sigma_history.append(sigma.copy())
    damage_history.append(d.copy())
    u_history.append(u.copy())
    residual_history.append(residuals)
    print(f"Damage at t = {t:.2f}:", d)

# ------------------------------ Plot Convergence ------------------------------ #
plt.figure()
for i, res in enumerate(residual_history):
    plt.plot(range(1, len(res) + 1), res, marker='o', label=f'Time step {i}')
plt.yscale('log')
plt.xlabel('Iteration')
plt.ylabel('Residual Norm')
plt.title('Convergence of Newton-Raphson Iterations')
plt.grid(True)
plt.show()

# Identify midpoint element index
mid_elem = input_data['nelem'] // 2  # This gives 10 for 20 elements

# Extract stress, damage, strain over time at midpoint
stress_mid = [sigma[mid_elem] for sigma in sigma_history]
damage_mid = [d[mid_elem] for d in damage_history]
strain_mid = [eps[mid_elem] for eps in eps_history]

# (c) Stress vs Time at midpoint
plt.figure(figsize=(8, 5))
plt.plot(time_steps, stress_mid, '-', label='Midpoint Stress')
plt.xlabel('Time [s]')
plt.ylabel('Stress [Pa]')
plt.title('(c) Stress vs Time at Midpoint')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# (d) Damage vs Time at midpoint
plt.figure(figsize=(8, 5))
plt.plot(time_steps, damage_mid, '-', color='red', label='Midpoint Damage')
plt.xlabel('Time [s]')
plt.ylabel('Damage')
plt.title('(d) Damage vs Time at Midpoint')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# (e) Stress vs Strain at midpoint
plt.figure(figsize=(8, 5))
plt.plot(strain_mid, stress_mid, '-', color='green', label='Midpoint Stress-Strain')
plt.xlabel('Strain')
plt.ylabel('Stress [Pa]')
plt.title('(e) Stress vs Strain at Midpoint')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()g