# -*- coding: utf-8 -*-
"""3dplasticity_with_all_5cases.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gREVwtjDNddi9NKDnKQ9lWTQS_zFb3VE
"""

def deviatoric_voigt(voigt_tensor):
    """
    Compute the deviatoric part of a 6x1 Voigt notation tensor.

    Parameters:
        voigt_tensor (np.ndarray): 6-element array (σxx, σyy, σzz, σyz, σxz, σxy)

    Returns:
        np.ndarray: Deviatoric part in Voigt notation
    """
    dev = np.array(voigt_tensor, dtype=float)
    trace = voigt_tensor[0] + voigt_tensor[1] + voigt_tensor[2]
    mean = trace / 3.0
    dev[0:3] -= mean
    return dev

def newton_raphson_plasticity(f_trial, n_trial, xi, E, K, H, eta, delta_t, sigma_inf, sigma_u, delta, tolerance, max_iter, is_time_dependent, q_trial):
    gamma = 0.0
    k = 0
    pi_dash = lambda xi: (sigma_inf - sigma_u) * (1 - np.exp(-delta * xi)) + K * xi
    pi_double_dash = lambda xi: delta * (sigma_inf - sigma_u) * np.exp(-delta * xi) + K

    if is_time_dependent:
        g = lambda gamma: f_trial - gamma * delta_t * (2*mu + 2/3*H + eta/delta_t) - np.sqrt(2/3)*(pi_dash(xi + gamma * delta_t*np.sqrt(2/3)) - pi_dash(xi))
        Dg = lambda gamma: -(2*mu + 2/3*pi_double_dash(xi + gamma * delta_t*np.sqrt(2/3)) + 2/3*H + eta/delta_t) * delta_t
    else:
        g = lambda gamma: f_trial - gamma * (2*mu + 2/3*H) - np.sqrt(2/3)*(pi_dash(xi + gamma*np.sqrt(2/3)) - pi_dash(xi))
        Dg = lambda gamma: -(2*mu + 2/3*pi_double_dash(xi + gamma*np.sqrt(2/3)) + 2/3*H)

    residual = g(gamma)

    while np.abs(residual) > tolerance and k < max_iter:
        gamma += -residual / Dg(gamma)
        residual = g(gamma)
        k += 1

    if k < max_iter:
        print(f"Newton-Raphson converged in {k} iterations.")
    else:
        print(f"Newton-Raphson did not converge within {max_iter} iterations.")

    print(f"Gamma value: {gamma:.6f}")

    if is_time_dependent:
      delta = 1 - (2*mu*gamma*deltat)/np.linalg.norm(deviatoric_voigt(Sig_trial)-q_bar_trial)
      delta_bar = 2*mu/(2*mu + 2/3*K + 2/3*H + eta/delta_t) - (1-delta)

      Eeptang = compute_Eptang(K, mu, delta, delta_bar, n_trial)

      q = q_trial - (pi_dash(xi + gamma * delta_t) - pi_dash(xi))
    else:
      delta = 1 - (2*mu*gamma)/np.linalg.norm(deviatoric_voigt(Sig_trial)-q_bar_trial)
      delta_bar = 2*mu/(2*mu + 2/3*K + 2/3*H ) - (1-delta)

      Eeptang = compute_Eptang(K, mu, delta, delta_bar, n_trial)
      q = q_trial - (pi_dash(xi + gamma*np.sqrt(2/3)) - pi_dash(xi))

    return gamma, Eeptang, q

def compute_Eptang(K, mu, delta, delta_bar, n_trial_voigt):
    I_voigt = np.eye(6)
    one_voigt = np.array([1, 1, 1, 0, 0, 0])

    # Outer product in Voigt form
    one_outer = np.outer(one_voigt, one_voigt)

    # Projection operator: I_dev = I - 1/3 * 1⊗1
    P_dev = I_voigt - (1.0 / 3.0) * one_outer

    # First term: kappa * 1⊗1
    term1 = K * one_outer

    # Second term: 2*mu*delta * (I - 1/3 * 1⊗1)
    term2 = 2 * mu * delta * P_dev

    # Third term: -2*mu*delta_bar * n⊗n
    n_outer = np.outer(n_trial_voigt, n_trial_voigt)
    term3 = -2 * mu * delta_bar * n_outer

    # Combine terms
    C_ep = term1 + term2 + term3
    return C_ep

def strain_tensor_to_voigt(eps_tensor):

    eps_voigt = np.zeros(6)
    eps_voigt[0] = eps_tensor[0, 0]  # ε_xx
    eps_voigt[1] = eps_tensor[1, 1]  # ε_yy
    eps_voigt[2] = eps_tensor[2, 2]  # ε_zz
    eps_voigt[3] = 2 * eps_tensor[1, 2]  # γ_yz
    eps_voigt[4] = 2 * eps_tensor[0, 2]  # γ_xz
    eps_voigt[5] = 2 * eps_tensor[0, 1]  # γ_xy
    return eps_voigt

import numpy as np


deltat= 0.001

# Define the strain components
exx = 0.01     # example value
eyy = 0.02     # example value
ezz = 0.03     # example value
nu = 0.3       # Poisson's ratio

E = 2.1e11
E = 70000e6
### can be changed later ###
K = 5e10;
H = 1e10
eta = 5e10
############################

sigma_u = 4.2e8
r0 = sigma_u / np.sqrt(E)
Ahs = 0.5
Bhs = 0
q_inf = Bhs * r0
sigma_inf = 2e9
delta = 150


# Construct the strain tensor
strain_tensor = np.array([
    [exx,        0.0,          0.0],
    [0.0,  -nu * exx,          0.0],
    [0.0,        0.0,   -nu * exx]
])


# Elastic constants
E11 = E * (1 - nu) / ((1 + nu) * (1 - 2 * nu))
E12 = E * nu / ((1 + nu) * (1 - 2 * nu))
E44 = E / ((1 + nu) * 2)

# Elasticity matrix (Voigt notation for 3D elasticity)
EE = np.array([
    [E11, E12, E12,   0,   0,   0],
    [E12, E11, E12,   0,   0,   0],
    [E12, E12, E11,   0,   0,   0],
    [  0,   0,   0, E44,   0,   0],
    [  0,   0,   0,   0, E44,   0],
    [  0,   0,   0,   0,   0, E44]
])

# Placeholder for stiffness matrix K (user should define it)
KK = K  # Ensure K is defined elsewhere in the script

# Hardening matrix
HH = (2 / 3) * H * np.eye(6)

# Shear modulus
mu = E44



# Prompt for time dependency
time_dependent = input("Is the analysis time-dependent? (yes/no): ")
is_time_dependent = time_dependent.lower() == 'yes'

# Prompt for plasticity case
plasticity_case = int(input("Select plasticity case:\n1) Perfect Plasticity\n2) Linear Isotropic Hardening\n3) Nonlinear Isotropic Hardening\n4) Linear Kinematic Hardening\n5) Nonlinear Isotropic and Linear Kinematic Hardening\nEnter your choice (1-5): "))

# Set flags based on user input
if plasticity_case == 1:
    plasticity_flag = "perfect_plasticity"
    E = E
    K = 0
    H = 0
elif plasticity_case == 2:
    plasticity_flag = "linear_isotropic"
    E = E
    K = K
    H = 0
elif plasticity_case == 3:
    plasticity_flag = "nonlinear_isotropic"
    E = E
    K = K
    H = 0
elif plasticity_case == 4:
    plasticity_flag = "linear_kinematic"
    E = E
    K = 0
    H = H
elif plasticity_case == 5:
    plasticity_flag = "combined_hardening"
    E = E
    K = K
    H = H
else:
    print("Invalid plasticity case selected. Using default (Perfect Plasticity).")
    plasticity_flag = "perfect_plasticity"




Eps_1=np.zeros(6)
Eps_2 = 0
Eps_3 = np.zeros(6)

eps_p_trial=np.zeros(6)
xi_trial = 0
xi_bar_trial = np.zeros(6)


#Sig_trial=np.zeros(6)
Sig_trial = strain_tensor_to_voigt(strain_tensor)
q_trial = 0
q_bar_trial = np.zeros(6)



n_trial = deviatoric_voigt(Sig_trial)/np.linalg.norm(deviatoric_voigt(Sig_trial))

f_trial = np.linalg.norm(deviatoric_voigt(Sig_trial)-q_bar_trial) - np.sqrt(2/3)*(sigma_u - q_trial)

#f_trial = 100
print(f"f_trial: \n{f_trial}")


if is_time_dependent:
  if f_trial <= 0:
    Eptang = EE
    n= n_trial

    Sig_new= Sig_trial
    q_new = q_trial
    q_bar_new = q_bar_trial

    eps_p_new = eps_p_trial
    xi_new = xi_trial
    xi_bar_new = xi_bar_trial

  else:
    if plasticity_flag == "nonlinear_isotropic" or plasticity_flag == "combined_hardening":
      gamma, Eeptang, q = newton_raphson_plasticity(f_trial, n_trial, xi_trial, E, K, H, eta, deltat, sigma_inf, sigma_u, delta, 1e-6, 15, is_time_dependent,q_trial)
    else:
      gamma = ((2*mu + 2/3*K + 2/3*H + (eta/deltat))**-1 ) * f_trial

      delta = 1 - (2*mu*gamma*deltat)/np.linalg.norm(deviatoric_voigt(Sig_trial)-q_bar_trial)
      delta_bar = 2*mu/(2*mu + 2/3*K + 2/3*H + eta/deltat) - (1-delta)

      Eptang = compute_Eptang(K, mu, delta, delta_bar, n_trial)

    Sig_new = Sig_trial - ((2*mu + 2/3*K + 2/3*H + (eta/deltat))**-1) * f_trial *2*mu* n_trial
    q_new = q_trial - ((2*mu + 2/3*K + 2/3*H + (eta/deltat))**-1) * f_trial * K * np.sqrt(2/3)
    q_bar_new = q_bar_trial + ((2*mu + 2/3*K + 2/3*H + (eta/deltat))**-1) * f_trial * 2/3 * H * n_trial

    eps_p_new = eps_p_trial + ((2*mu + 2/3*K + 2/3*H + (eta/deltat))**-1) * f_trial * n
    xi_new = xi_trial + ((2*mu + 2/3*K + 2/3*H + (eta/deltat))**-1) * f_trial * np.sqrt(2/3)
    xi_bar_new = xi_bar_trial - ((2*mu + 2/3*K + 2/3*H + (eta/deltat))**-1) * f_trial * n_trial
else:
  if f_trial <= 0:
    Eptang = EE
    n= n_trial

    Sig_new= Sig_trial
    q_new = q_trial
    q_bar_new = q_bar_trial

    eps_p_new = eps_p_trial
    xi_new = xi_trial
    xi_bar_new = xi_bar_trial
  else:
    if plasticity_flag == "nonlinear_isotropic" or plasticity_flag == "combined_hardening":
      gamma, Eeptang, q = newton_raphson_plasticity(f_trial, n_trial, xi_trial, E, K, H, eta, deltat, sigma_inf, sigma_u, delta, 1e-6, 15, is_time_dependent,q_trial)
    else:
      gamma = ((2*mu + 2/3*K + 2/3*H)**-1 ) * f_trial

      delta = 1 - (2*mu*gamma)/np.linalg.norm(deviatoric_voigt(Sig_trial)-q_bar_trial)
      delta_bar = 2*mu/(2*mu + 2/3*K + 2/3*H ) - (1-delta)

      Eptang = compute_Eptang(K, mu, delta, delta_bar, n_trial)

    Sig_new = Sig_trial - ((2*mu + 2/3*K + 2/3*H)**-1) * f_trial * 2 * mu * n_trial
    q_new = q_trial - ((2*mu + 2/3*K + 2/3*H)**-1) * f_trial * K * np.sqrt(2/3)
    q_bar_new = q_bar_trial + ((2*mu + 2/3*K + 2/3*H)**-1) * f_trial * 2/3 * H * n_trial

    eps_p_new = eps_p_trial + ((2*mu + 2/3*K + 2/3*H)**-1) * f_trial * n_trial
    xi_new = xi_trial + ((2*mu + 2/3*K + 2/3*H)**-1) * f_trial * np.sqrt(2/3)
    xi_bar_new = xi_bar_trial - ((2*mu + 2/3*K + 2/3*H)**-1) * f_trial * n_trial



print(f"Eptang: \n{Eptang}")

import numpy as np
import matplotlib.pyplot as plt

def generate_strain_history(strain_rate, time_step):
    # Define strain levels
    strain_points = [0.0, 0.02, -0.02, 0.02]

    # Build strain history
    strain_history = []

    for i in range(len(strain_points) - 1):
        start = strain_points[i]
        end = strain_points[i + 1]
        delta_strain = end - start
        num_steps = int(abs(delta_strain) / (strain_rate * time_step))
        if num_steps == 0:
            continue  # Skip if no steps required

        strain_segment = np.linspace(start, end, num_steps, endpoint=False)
        strain_history.extend(strain_segment)

    # Add final point to ensure it ends at last strain value
    strain_history.append(strain_points[-1])

    # Create corresponding time array
    total_steps = len(strain_history)
    time_array = np.arange(total_steps) * time_step

    return np.array(time_array), np.array(strain_history)

# Example usage:
strain_rate = 1e-2     # strain per second
time_step = 0.05        # seconds

time, strain = generate_strain_history(strain_rate, time_step)

# Plot the strain history
plt.plot(time, strain)
plt.xlabel('Time (s)')
plt.ylabel('Strain')
plt.title('Strain History')
plt.grid(True)
plt.show()


print(strain)

import numpy as np
import matplotlib.pyplot as plt

deltat = 0.001
nu = 0.3       # Poisson's ratio

E = 70000e6
K = 5e10
H = 1e10
eta = 5e10

sigma_u = 4.2e8
r0 = sigma_u / np.sqrt(E)
Ahs = 0.5
Bhs = 0
q_inf = Bhs * r0
sigma_inf = 2e9
delta = 150

# Elastic constants
E11 = E * (1 - nu) / ((1 + nu) * (1 - 2 * nu))
E12 = E * nu / ((1 + nu) * (1 - 2 * nu))
E44 = E / ((1 + nu) * 2)
EE = np.array([
    [E11, E12, E12,   0,   0,   0],
    [E12, E11, E12,   0,   0,   0],
    [E12, E12, E11,   0,   0,   0],
    [  0,   0,   0, E44,   0,   0],
    [  0,   0,   0,   0, E44,   0],
    [  0,   0,   0,   0,   0, E44]
])
mu = E44

# Prompt user input
time_dependent = input("Is the analysis time-dependent? (yes/no): ")
is_time_dependent = time_dependent.lower() == 'yes'

plasticity_case = int(input(
    "Select plasticity case:\n"
    "1) Perfect Plasticity\n"
    "2) Linear Isotropic Hardening\n"
    "3) Nonlinear Isotropic Hardening\n"
    "4) Linear Kinematic Hardening\n"
    "5) Nonlinear Isotropic and Linear Kinematic Hardening\n"
    "Enter your choice (1-5): "
))

if plasticity_case == 1:
    plasticity_flag = "perfect_plasticity"
    K = 0; H = 0
elif plasticity_case == 2:
    plasticity_flag = "linear_isotropic"
    H = 0
elif plasticity_case == 3:
    plasticity_flag = "nonlinear_isotropic"
    H = 0
elif plasticity_case == 4:
    plasticity_flag = "linear_kinematic"
    K = 0
elif plasticity_case == 5:
    plasticity_flag = "combined_hardening"
else:
    print("Invalid plasticity case selected. Using default (Perfect Plasticity).")
    plasticity_flag = "perfect_plasticity"
    K = 0; H = 0

# === Initialize state ===
eps_p_trial = np.zeros(6)
xi_trial = 0
xi_bar_trial = np.zeros(6)
q_trial = 0
q_bar_trial = np.zeros(6)

# === Strain input vector ===
exx_vals = strain  # Example time-dependent strain path

# === Output storage ===
eps_out = []
sig_out = []

# === Time loop ===
for step, exx in enumerate(exx_vals):
    strain_tensor = np.array([
        [exx,        0.0,          0.0],
        [0.0,  -nu * exx,          0.0],
        [0.0,        0.0,   -nu * exx]
    ])

    # Total strain vector (6D Voigt)
    eps = strain_tensor_to_voigt(strain_tensor)

# Trial stress from elastic predictor
    Sig_trial = EE @ (eps - eps_p_trial)

# Deviatoric part of stress
    s_dev = Sig_trial - np.mean(Sig_trial[:3]) * np.array([1, 1, 1, 0, 0, 0])

    n_trial = deviatoric_voigt(Sig_trial) / np.linalg.norm(deviatoric_voigt(Sig_trial))
    f_trial = np.linalg.norm(deviatoric_voigt(Sig_trial) - q_bar_trial) - np.sqrt(2 / 3) * (sigma_u - q_trial)

    if is_time_dependent:
        if f_trial <= 0:
            Eptang = EE
            Sig_new = Sig_trial
            q_new = q_trial
            q_bar_new = q_bar_trial
            eps_p_new = eps_p_trial
            xi_new = xi_trial
            xi_bar_new = xi_bar_trial
        else:
            if plasticity_flag in ["nonlinear_isotropic", "combined_hardening"]:
                gamma, Eptang, q = newton_raphson_plasticity(
                    f_trial, n_trial, xi_trial, E, K, H, eta, deltat,
                    sigma_inf, sigma_u, delta, 1e-6, 15, is_time_dependent, q_trial
                )
            else:
                gamma = ((2*mu + 2/3*K + 2/3*H + (eta/deltat))**-1 ) * f_trial
                delta = 1 - (2*mu*gamma*deltat)/np.linalg.norm(deviatoric_voigt(Sig_trial)-q_bar_trial)
                delta_bar = 2*mu/(2*mu + 2/3*K + 2/3*H + eta/deltat) - (1-delta)
                Eptang = compute_Eptang(K, mu, delta, delta_bar, n_trial)

            Sig_new = Sig_trial - ((2*mu + 2/3*K + 2/3*H + (eta/deltat))**-1) * f_trial * 2 * mu * n_trial
            q_new = q_trial - ((2*mu + 2/3*K + 2/3*H + (eta/deltat))**-1) * f_trial * K * np.sqrt(2/3)
            q_bar_new = q_bar_trial + ((2*mu + 2/3*K + 2/3*H + (eta/deltat))**-1) * f_trial * 2/3 * H * n_trial
            eps_p_new = eps_p_trial + ((2*mu + 2/3*K + 2/3*H + (eta/deltat))**-1) * f_trial * n_trial
            xi_new = xi_trial + ((2*mu + 2/3*K + 2/3*H + (eta/deltat))**-1) * f_trial * np.sqrt(2/3)
            xi_bar_new = xi_bar_trial - ((2*mu + 2/3*K + 2/3*H + (eta/deltat))**-1) * f_trial * n_trial
    else:
        if f_trial <= 0:
            Eptang = EE
            Sig_new = Sig_trial
            q_new = q_trial
            q_bar_new = q_bar_trial
            eps_p_new = eps_p_trial
            xi_new = xi_trial
            xi_bar_new = xi_bar_trial
        else:
            if plasticity_flag in ["nonlinear_isotropic", "combined_hardening"]:
                gamma, Eptang, q = newton_raphson_plasticity(
                    f_trial, n_trial, xi_trial, E, K, H, eta, deltat,
                    sigma_inf, sigma_u, delta, 1e-6, 15, is_time_dependent, q_trial
                )
            else:
                gamma = ((2*mu + 2/3*K + 2/3*H)**-1 ) * f_trial
                delta = 1 - (2*mu*gamma)/np.linalg.norm(deviatoric_voigt(Sig_trial)-q_bar_trial)
                delta_bar = 2*mu/(2*mu + 2/3*K + 2/3*H ) - (1-delta)
                Eptang = compute_Eptang(K, mu, delta, delta_bar, n_trial)

            Sig_new = Sig_trial - ((2*mu + 2/3*K + 2/3*H)**-1) * f_trial * 2 * mu * n_trial
            q_new = q_trial - ((2*mu + 2/3*K + 2/3*H)**-1) * f_trial * K * np.sqrt(2/3)
            q_bar_new = q_bar_trial + ((2*mu + 2/3*K + 2/3*H)**-1) * f_trial * 2/3 * H * n_trial
            eps_p_new = eps_p_trial + ((2*mu + 2/3*K + 2/3*H)**-1) * f_trial * n_trial
            xi_new = xi_trial + ((2*mu + 2/3*K + 2/3*H)**-1) * f_trial * np.sqrt(2/3)
            xi_bar_new = xi_bar_trial - ((2*mu + 2/3*K + 2/3*H)**-1) * f_trial * n_trial

    # Update state
    eps_p_trial = eps_p_new
    xi_trial = xi_new
    xi_bar_trial = xi_bar_new
    q_trial = q_new
    q_bar_trial = q_bar_new

    eps_out.append(strain_tensor_to_voigt(strain_tensor))
    sig_out.append(Sig_new)

# Convert to arrays for plotting
eps_out = np.array(eps_out)
sig_out = np.array(sig_out)

# === Plot ===
plt.figure()
plt.plot(eps_out[:, 0], sig_out[:, 0] / 1e6, label='σₓₓ vs εₓₓ')
plt.xlabel("Axial Strain εₓₓ")
plt.ylabel("Axial Stress σₓₓ [MPa]")
plt.title("Stress-Strain Response")
plt.grid(True)
plt.legend()
plt.show()